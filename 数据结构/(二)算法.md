# (二)算法

<font face="Microsoft Yahei">

算法是解决特定问题的步骤描述, 在计算机中表现为指令的有限序列. 并且每条指令表示一个或多个操作.(算法是描述解决问题的方法.)

## 算法的特性

算法有五个基本特性: 输入, 输出, 有穷性, 确定性和可行性.

## 算法的效率

通常取决于以下因素:
- 算法采用的策略, 方法.
- 编译产生的代码质量.
- 问题的输入规模.
- 机器执行指令的速度.

## 算法的时间复杂度

算法的时间复杂度就是 算法的时间量度. 

> 公式是 : T(n) = O(f(n))

一般用O( ) 来体现算法的时间复杂度的记录方式. 其中 O(1) 叫常数阶, O(n)叫线型阶, O(n²) 叫平方阶.

表示随着问题规模n的增大, 算法执行时间的增长率, 和 f(n)的增长率相同. 称为算法的渐进时间复杂度, 也成为算法的时间复杂度.

进行算法分析时, 语句的总体执行次数T(n)是关于问题规模(n)的函数, 进而根据分析T(n)随着n变化的情况来确定T(n)的数量级.

一般来说随着n的增长, T(n) 增长最慢的算法为最优算法.

## 如何推导一个算法的时间复杂度 即O().

有个公式, 但是不是绝对的.

>-   用常数 1 来取代运行中所有通过加法得到的常数. 
>-   在修改后的运行次数的函数中, 只保留最高阶项.
>-  如果最高阶存在且不是 1 , 则去除以这个项相乘的常数.
>-  得到的结果就是大O阶.

---
例子1:
```c
int sum = 0, n = 100;
sum = (1+n) * n / 2;
printf("%d", sum);
```
这个算法的运行次数的函数是 f(n) = 3, 则为 1 ,在保留高阶项时发现没有最高阶项, 所以这个算法的时间复杂度为 O(1).常数阶的算法执行的次数是恒定的, 不会根据n的变化而变化.

---
例子2:
```c
int i;
for(i = 0; i < n; i++)
{
    /* 时间复杂度为O(1)的程序步骤序列 */
}
```
这个算法的时间复杂度为 O(n)

---
例子3:
```c
int count = 1;
while(count < n)
{
    count = count * 2;
}
```
在这个例子中, 每次count * 2之后都距离n更近, 也就是说多少个2相乘会大于n并跳出循环, 有2ⁿ = n 得到 n = ㏒₂n. 所以这个循环的时间复杂度是 O(㏒₂n)

---
例子4:
```c
int i, j
for(i=0; i< n; i++)
{
    for(j=i; j < n; j++)
    {
        /* 时间复杂度为O(1)的程序步骤序列 */
    }
}
```
最后推导出来为: 
n + (n - 1) + (n - 2) + (n - 3) + ... + 1 = ½n(n+1) = ½n² + ½n

使用大O推导公式来计算这个算法的时间复杂度:
1. 没有加法常数项不予考虑;
2. 只保留最高阶项, 即 n²的项;
3. 去除这个项相乘的常数, 即½;
4. 最终得到大O为 O(n²).

---
上面的例子不是很全, 但就是稍微让我们能够了解一些关于大O的算法. 下面这张表给出一些常见的时间复杂度:
![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190424184145752-984332991.png)
最常用的时间复杂度所耗费的时间有小到大依次是:
>O(1) < O(㏒n) < O(n) < O(n㏒n) < O(n²) < O(n)³ < O(2ⁿ) < O(n!) < O(nⁿ)