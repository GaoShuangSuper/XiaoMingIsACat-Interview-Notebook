## 装饰模式(Decorator)

装饰模式也称装饰器模式, 英文是decorator. 官方给出的解释是`在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。`
emm.. 太特么抽象了,根本看不懂说的啥意思.

我这里总结了一些使用该模式的场景, 如果遇到以下需求可以考虑尝试使用装饰模式去实现:

>*这里必须做到充分理解使用场景, 才能够在实际的需求中快速分析出应该使用的设计模式. 下面列出的情况1中的情形实际上最理想的方式应该是代理模式(后面会讲到), 我当时学到这里的时候并不知道代理模式, 所以使用的是装饰器模式实现的. 但是后期发现装饰器模式的最佳实践是灵活的扩展类的`职责`*

- **项目中有种比较commom的类, 比如log类, 一般继承或者实现于log4net等开源库. 而我们在使用log的时候, 都是将一些string类型的信息流写入到文件当中. 突然有一天上峰传达说你所在的A部门使用的log的格式需要改成json的格式.那怎么办? 一般情况下根据设计模式的各种原则, 不介意直接改log类. 所以通过实现一个装饰类来扩展log, 让你们A部门在使用log类写日志的时候, 将日志内容进行json格式化的装饰后, 再写入日志文件.(`其实这里使用代理模式也比较合理..`)**
- *需要扩展一个类的功能、或者给一个类添加附加的职责时*
- *需要动态的给一个对象添加功能，这些功能可以再动态的撤销时*
- *需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实*
- *当不能采用生成子类的方式进行扩充时*
- [等待补充]...

上述情况, 可以根据下面的结构图, 构建装饰模式的扩展.
然后对于情况1, 我写了个demo code已经上传至[git](https://github.com/itdennis/DennisDemos/tree/master/Decorator_1)了.

![](https://img2018.cnblogs.com/blog/1216080/201903/1216080-20190328230536629-1456132203.png)