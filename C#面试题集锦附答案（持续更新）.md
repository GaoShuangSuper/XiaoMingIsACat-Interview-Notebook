# C#面试题集锦附答案

1. `本篇面试题集锦归纳了以下参考材料. 特在此处向之前总结的人表示感谢`

    [https://www.cnblogs.com/lgxlsm/p/5256482.html](https://www.cnblogs.com/lgxlsm/p/5256482.html)

2. `值类型和引用类型的区别`

    值类型包括简单类型、结构体类型和枚举类型，引用类型包括自定义类、数组、接口、委托等。
    - 赋值方式：将一个值类型变量赋给另一个值类型变量时，将复制包含的值。这与引用类型变量的赋值不同，引用类型变量的赋值只复制对象的引用（即内存地址，类似C++中的指针），而不复制对象本身。
    - 继承：值类型不可能派生出新的类型，所有的值类型均隐式派生自 System.ValueType。但与引用类型相同的是，结构也可以实现接口。
    - null：与引用类型不同，值类型不可能包含 null 值。然而，可空类型功能允许将 null 赋给值类型。
    - 每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值，值类型初始会默认为0，引用类型默认为null。
    2.5 值类型存储在栈中，引用类型存储在托管堆中。

3. `结构和类的区别`

    - 结构是值类型, 类是引用类型;
    - class需要new关键字实例化对象, struct可以不使用new关键字实例化对象;
    - 结构体不支持抽象, 类支持;

4. `delegate是值类型还是引用类型? enum, int[]和string呢?`

    enum枚举是值类型,其他的都是引用类型.

5. `堆和栈的区别`

    - 值类型大多分配在栈上, 引用类型都分配在堆上;
    - 栈由操作系统管理, 栈上的变量在其作用域完成后就被释放, 效率高但是空间有限.
    - 栈是基于线程的.所以栈有线程栈.而堆是基于进程的,一个进程分配一个堆.堆的大小由GC根据运行情况动态控制;

6. `结构对象能够分配到堆上面吗?什么情况下发生,有什么需要注意的吗?`

    结构是值类型,有两种情况会将结构分配到堆上面:
    - 结构作为class的字段或者属性时,会随着class分配到堆上面;
    - 装箱后会在堆中存储,尽量避免值类型的装箱, 值类型的装箱和拆箱都有性能损失.

7. `参数的值传递和引用传递的区别`

    - 按值传递:对于值类型的参数传递的是值得拷贝副本.对于引用类型的参数传递的是引用变量的内存地址,他们指向的还是同一个变量;
    - 按照引用传递: 通过ref和out传递参数的内存地址, 值类型和引用类型的效果是相通的.

8. `out和ref区别`

    - out和ref都是传递变量所引用的地址.
    - 他们使用的机制有所不同, ref要求参数在使用之前要显示的初始化, out要在方法的内部初始化.
    - 定义的两个方法如果仅有的区别是参数的out和ref,则不允许被重载. 因为编译角度来看二者的本质是相同的.

9. `有几种方法判断是值类型还是引用类型?`

    简单来说继承自System.ValueType的是值类型,否则为引用类型.

10. `C#支持哪些预定义的值类型和引用类型`

    - 值类型: 整数,浮点数, 字符, bool和decimal
    - 引用类型: Object, String

11. `说说值类型和引用类型的生命周期`

    - 值类型在其作用域完成后释放.
    - 引用类型由GC进行回收.
    - 可参考问题5.

12. `如果结构体中定义了引用类型,那么在内存中如何存储?`

    ```csharp

    public struct MyStruct  
    {
        public int Index;
        public User User;  
    }
    ```

    Mystruct存储在栈中, 其字段存储在堆中, MyStruct.User字段存储指向User对象的内存地址.

13. `什么是装箱和拆箱? 什么是箱子? 箱子放在哪里? 装箱和拆箱对性能有什么影响?  `

    - 装箱就是值类型转换成引用类型, 拆箱就是引用类型转换成值类型.
    - 箱子就是引用类型对象
    - 箱子放在托管堆上
    - 装箱拆箱都涉及到内存的分配和对象的创建, 对性能有较大的影响.

14. `装箱的过程`

    - 在堆中申请内存,内存的大小为值类型的大小.再加上额外的固定空间(TypeHandle和同步索引块)
    - 将值类型的字段值(x=1024)拷贝到新分配的内存中
    - 返回新引用的对象的地址(给引用变量Object o)

15. `拆箱的过程`

    - 检查实例对象(Object o)是否有效,比如是否为null,其装箱的类型与拆箱的类型是否一致, 如不一致则抛出异常;
    - 指针返回, 即获取装箱对象(object o)中值类型的字段值得地址;
    - 字段拷贝, 把装箱对象中的值类型字段拷贝到栈上, 意思就是创建一个新的值类型来存储拆箱后的值.

16. `String字符串是什么类型(单独列出来是因为重要)`

    引用类型

17. `在处理字符串的拼接时候,最好采用什么方式, 理由是什么?`

    - 少量字符串的拼接使用String.Contact
    - 大量字符串的拼接使用String.Builder, 性能虽好但是开销大,用的时候最好给个容量.
    - 单用string会创建大量字符串对象

18. `所有类型都继承自System.Object吗?`

    基本上是的，所有值类型和引用类型都继承自System.Object，接口是一个特殊的类型，不继承自System.Object.

19. `解释一下virtual、sealed、override和abstract的区别`

    - virtual申明虚方法的关键字，说明该方法可以被重写
    - sealed说明该类(方法)不可被继承
    - override重写基类的方法
    - abstract申明抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实例化

20. `接口和类的异同`

    不同点：
    1. 接口不能直接实例化。
    2. 接口只包含方法或属性的声明，不包含方法的实现。
    3. 接口可以多继承，类只能单继承。
    4. 表达的含义不同，接口主要定义一种规范，统一调用方法，也就是规范类，约束类，类是方法功能的实现和集合

    相同点：
    1. 接口、类和结构都可以从多个接口继承。
    2. 接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。
    3. 接口和类都可以包含事件、索引器、方法和属性。

21. `抽象类和接口的异同`

    1. 继承:接口可以多继承, 抽象类则不可.
    2. 表达的概念: 接口用于规范,更强调契约. 抽象类表示共性, 表示一类事物的高度聚合. 对于继承抽象类的子类来说, 属于IS A的关系. 而接口是用来强调行为规范, 属于CAN DO的关系.因此对于实现接口的子类来说, 其行为需要按照接口来完成.
    3. 方法的实现: 抽象类中既可以给出方法的实现,也可以不给. 接口中的方法既不能给出方法的实现部分,又不能添加修饰符.
    4. 子类重写: 继承类对于两者所涉及方法的实现是不同的。继承类对于抽象类所定义的抽象方法，可以不用重写，也就是说，可以延用抽象类的方法；而对于接口类所定义的方法或者属性来说，在继承类中必须重写，给出相应的方法和属性实现.
    5. 新增方法的影响: 在抽象类中，新增一个方法的话，继承类中可以不用作任何处理；而对于接口来说，则需要修改继承类，提供新定义的方法.
    6. 接口可以作用于值类型（枚举可以实现接口）和引用类型；抽象类只能作用于引用类型.
    7. 接口不能包含字段和已实现的方法，接口只包含方法、属性、索引器、事件的签名；抽象类可以定义字段、属性、包含有实现的方法.

22. `override(重写)和overload(重载)的区别?`

    overload：当类包含两个名称相同但签名不同(方法名相同,参数列表不相同)的方法时发生方法重载。用方法重载来提供在语义上完成相同而功能不同的方法。
    override：在类的继承中使用，通过覆写子类方法可以改变父类虚方法的实现。
    
    主要区别：
    1. 方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。 
    2. 覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。 
    3. 覆盖要求参数列表相同；重载要求参数列表不同。 
    4. 覆盖关系中，调用那个方法体，是根据对象的类型来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。

23. `class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？`

    随类型对象存储在内存的加载堆上，因为加载堆不受GC管理，其生命周期随AppDomain，不会被GC回收.

24. `const和readonly有什么区别？`

    - 初始化的位置不同. const常量必须在声明的时候赋值.readonly常量可以在声明处赋值,也可以在构造函数中赋值.
    - 修饰的参数不同. const可以修饰类的字段, 也可以修饰局部变量. readonly只能修饰类的字段.
    - const是编译时常量, 在编译时确定该值,且值在编译时内联到代码中;readonly是运行时常量,在运行时确定值.
    - const默认是静态的;readonly如果要声明为静态需要显示声明.
    - `const只能修饰基元类型或者值为null的其他引用类型; readonly可以修饰任何类型`

    下面的代码片段阐释两者的区别:
    ```csharp
    public class Program
    {
        public readonly int PORT;
        static void Main(string[] args)
        {
            B a = new B();
            Console.WriteLine(a.PORT);
            Console.WriteLine(B.PORT2);
            Console.WriteLine(a.PORT3.ccc);
            Console.ReadLine();
        }
    }

    class B
    {
        //readonly即可以在声明处赋值，也可以在构造方法里赋值
        public readonly int PORT;
        //const必须在声明的同时赋值
        public const int PORT2 = 10;

        //错误public const A PORT3 =  new A()    const只能修饰基元类型或值为null的其他引用类型

        //readonly可以是任何类型
        public readonly A PORT3 = new A();
        public B()
        {

            PORT = 11;
        }
    }

    class A
    {
        public string ccc = "aaaa";
    }
    ```

25. `字段和属性的异同`

    - 属性提供了强大的灵活手段来操作字段.
    - 出于面向对象的封装性, 一般不将字段赋为public.
    - 属性允许在get和set中编写代码.
    - 属性允许控制get和set的访问性.
    - `属性可以使用override和new`

26. `静态成员和非静态成员的区别`

    - 静态成员使用static关键字修饰.静态成员在加载类的时候就会被加载, 并通过类进行访问.
    - 非静态成员没有static修饰符. 在对象实例化时被创建, 通过对象来进行访问.
    - 一个类的所有实例的同一静态变量的值是同一个. 同一个类的不同实例的同一非静态变量的值可以是不同的值.
    - 静态函数中不能使用非静态成员.

27. `特性(Attribute)是什么,如何使用?`

    特性与属性是完全不相同的两个概念，只是在名称上比较相近。Attribute特性就是关联了一个目标对象的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在dll内的元数据，它本身没什么意义。运行期以反射的方式来获取附加信息.

28. `C#中的委托是什么? 事件是否是委托?`

    - 委托就是允许方法当做参数进行传递.
    - C#中的委托都继承自System.Delegate类型.
    - 委托类型的声明和方法的签名类似, 需要返回值和参数.
    - 委托是一种可以封装命名(匿名)方法的引用类型.把方法当做指针传递.但是委托是面向对象并且类型安全的.
    - 事件可以理解成委托. 其内部是用委托来实现的.

29. `简述一下一个引用对象的生命周期？`

    - new创建对象并分配内存
    - 对象初始化
    - 对象操作、使用
    - 资源清理（非托管资源）
    - GC垃圾回收

30. `GC进行垃圾回收时的主要流程是？`

    ① 标记：先假设所有对象都是垃圾，根据应用程序根Root遍历堆上的每一个引用对象，生成可达对象图，对于还在使用的对象（可达对象）进行标记（其实就是在对象同步索引块中开启一个标示位).

    ② 清除：针对所有不可达对象进行清除操作，针对普通对象直接回收内存，而对于实现了终结器的对象（实现了析构函数的对象）需要单独回收处理。清除之后，内存就会变得不连续了，就是步骤3的工作了.

    ③ 压缩：把剩下的对象转移到一个连续的内存，因为这些对象地址变了，还需要把那些Root跟指针的地址修改为移动后的新地址。

31. `GC在哪些情况下回进行回收工作？`

    - 内存不足溢出时（0代对象充满时）
    - Windwos报告内存不足时，CLR会强制执行垃圾回收
    - CLR卸载AppDomian，GC回收所有
    - 调用GC.Collect
    - 其他情况，如主机拒绝分配内存，物理内存不足，超出短期存活代的存段门限.

32. `using() 语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？`
    using() 只是一种语法形式，其本质还是try…finally的结构，可以保证Dispose始终会被执行.

33. `解释一下C#里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？`

    C#里的析构函数其实就是终结器Finalize，因为长得像C++里的析构函数而已。
    有些编程建议里不推荐使用析构函数要原因在于：第一是Finalize本身性能并不好；其次很多人搞不清楚Finalize的原理，可能会滥用，导致内存泄露，因此就干脆别用了.

34. `Finalize() 和 Dispose() 之间的区别？`

    Finalize() 和 Dispose()都是.NET中提供释放非托管资源的方式，他们的主要区别在于执行者和执行时间不同：

    finalize由垃圾回收器调用；dispose由对象调用。
    finalize无需担心因为没有调用finalize而使非托管资源得不到释放，而dispose必须手动调用。

    finalize不能保证立即释放非托管资源，Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间；而dispose一调用便释放非托管资源。

    只有class类型才能重写finalize，而结构不能；类和结构都能实现IDispose。

    另外一个重点区别就是终结器会导致对象复活一次，也就说会被GC回收两次才最终完成回收工作，这也是有些人不建议开发人员使用终结器的主要原因。

35. `.NET中的托管堆中是否可能出现内存泄露的现象?`

    是的，可能会。

    - 不正确的使用静态字段，导致大量数据无法被GC释放；
    - 没有正确执行Dispose()，非托管资源没有得到释放；
    - 不正确的使用终结器Finalize()，导致无法正常释放资源；
    - 其他不正确的引用，导致大量托管对象无法被GC释放；

36. `在托管堆上创建新对象有哪几种常见方式？`

    - new一个对象；
    - 字符串赋值，如string s1=”abc”；
    - 值类型装箱；

37. `描述线程与进程的区别？`

    - 一个应用程序实例是一个进程，一个进程内包含一个或多个线程，线程是进程的一部分；
    - 进程之间是相互独立的，他们有各自的私有内存空间和资源，进程内的线程可以共享其所属进程的所有资源；

38. `lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？`

    lock的锁对象要求为一个引用类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。

    对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向一个真正的锁（同步块），这个锁（同步块）会被复用。

39. `多线程和异步有什么关系和区别？`

    多线程是实现异步的主要方式之一，异步并不等同于多线程。实现异步的方式还有很多，比如利用硬件的特性、使用进程或纤程等。在.NET中就有很多的异步编程支持，比如很多地方都有Begin***、End***的方法，就是一种异步编程支持，她内部有些是利用多线程，有些是利用硬件的特性来实现的异步编程。

40. `线程池的优点有哪些？又有哪些不足？`

    优点：减小线程创建和销毁的开销，可以复用线程；也从而减少了线程上下文切换的性能损失；在GC回收时，较少的线程更有利于GC的回收效率。

    缺点：线程池无法对一个线程有更多的精确的控制，如了解其运行状态等；不能设置线程的优先级；加入到线程池的任务（方法）不能有返回值；对于需要长期运行的任务就不适合线程池。

41. `锁都有哪些?`


