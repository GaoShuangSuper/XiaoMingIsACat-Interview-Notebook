# 设计模式

## 简单工厂模式(Simple Factory)

添加一个工厂类, 在工厂类中添加一个创建实例的方法, 根据参数的不同, 初始化不同的实例.

![foundation](https://img2018.cnblogs.com/blog/1216080/201903/1216080-20190328141424899-1242404801.png)

[代码示例](https://github.com/itdennis/DennisDemos/tree/master/Design_Patterns_Demos/SimpleFactory)

## 策略模式(Strategy)

### 简单工厂的不足

`面向对象的编程,并不是类越多越好, 类的划分是为了封装, 但分类的基础是抽象, 具有相同属性和功能的对象的抽象集合才是类.` 所以有些Action看起来只是行为的不同, 但是抽象分析后的算法是一样的, 所以应该抽象为一个类.

使用简单工厂模式设计的抽象基类, 其他实际操作类继承这个基类. 然后用工厂来初始化操作类的实例.
![](https://img2018.cnblogs.com/blog/1216080/201903/1216080-20190328142855139-1466137488.png)
`但是这种方式只能解决操作类的实例创建问题, 而且由于工厂本身包括了所有的实例创建方式. 所以每次维护和扩展都要改动这个工厂, 易导致代码需要重新部署, 面对算法的时常变动, 应该有个更合理的模式.`

### 引入策略模式

`定义了算法家族, 分别封装起来, 让他们之间可以互相替换, 此模式让算法的变化不影响使用算法的客户.`

![](https://img2018.cnblogs.com/blog/1216080/201903/1216080-20190328144108112-84527345.png)

### 策略模式的优点

策略模式的引入使得client只需要了解context即可, 由context负责和client沟通后,对Strategy类对应的初始化操作.然后由context调用执行相应的操作类的方法, 将结果返回给client即可. 这种方式在解耦上也有很大的意义.

另外策略模式的一个好处是方便实际操作类的单元测试. 因为每个算法都有自己的类, 所以可以通过自己的接口进行单元测试.

策略模式封装了变化. 将不同的算法放入不同的实际操作类中, 分别执行抽象出来的公用方法是其最大的优势.

### 示例

[GitLink](https://github.com/itdennis/DennisDemos/tree/master/StrategyDemos)

## 装饰模式(Decorator)

装饰模式也称装饰器模式, 英文是decorator. 官方给出的解释是`在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。`
emm.. 太特么抽象了,根本看不懂说的啥意思.

我这里总结了一些使用该模式的场景, 如果遇到以下需求可以考虑尝试使用装饰模式去实现:

>*这里必须做到充分理解使用场景, 才能够在实际的需求中快速分析出应该使用的设计模式. 下面列出的情况1中的情形实际上最理想的方式应该是代理模式(后面会讲到), 我当时学到这里的时候并不知道代理模式, 所以使用的是装饰器模式实现的. 但是后期发现装饰器模式的最佳实践是灵活的扩展类的`职责`*

- **项目中有种比较commom的类, 比如log类, 一般继承或者实现于log4net等开源库. 而我们在使用log的时候, 都是将一些string类型的信息流写入到文件当中. 突然有一天上峰传达说你所在的A部门使用的log的格式需要改成json的格式.那怎么办? 一般情况下根据设计模式的各种原则, 不介意直接改log类. 所以通过实现一个装饰类来扩展log, 让你们A部门在使用log类写日志的时候, 将日志内容进行json格式化的装饰后, 再写入日志文件.(`其实这里使用代理模式也比较合理..`)**
- *需要扩展一个类的功能、或者给一个类添加附加的职责时*
- *需要动态的给一个对象添加功能，这些功能可以再动态的撤销时*
- *需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实*
- *当不能采用生成子类的方式进行扩充时*
- [等待补充]...

上述情况, 可以根据下面的结构图, 构建装饰模式的扩展.
然后对于情况1, 我写了个demo code已经上传至[git](https://github.com/itdennis/DennisDemos/tree/master/Decorator_1)了.

![](https://img2018.cnblogs.com/blog/1216080/201903/1216080-20190328230536629-1456132203.png)

## 代理模式(Proxy)

官方解释: 代理模式是一种结构型设计模式，它可以为其他对象提供一种代理以控制对这个对象的访问。

就是说代理类与被代理的类具有相同的接口, 然后客户端必须通过代理类来与被代理的类进行交互. 而代理一般在交互的前后进行某些特定的处理.

