# 大型的项目中数据库的解决方案 -- 分库分表

<font face="Microsoft Yahei">

## 分库分表

对于中大型项目(单表数据量在百万级以上), 数据库的效率就会降低, 应该第一时间采取分库分表来提升数据库效率. 分库分表一般采用`垂直拆分`以及`水平拆分`

- 垂直拆分

    比较简单, 是指数据库量级大了以后, 从业务角度拆分出多个库. 如下图:
    
    ![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425130519408-1901683794.png)

- 水平拆分

    是指同一个业务数据量大以后, 进行的同一个业务的拆分, 叫水平拆分.

    ![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425130830243-1857877400.png)

    数据库的单表存储量是有一定的限制的, 如果超过了这个限制, 效率会降低. 所以对于超过百万级的单表, 建议进行水平拆分.

## 分库分表方案

- hash取模 (扩容时需要做数据迁移)

    比如一个单表超过4k万数据, 我们准备将其分为4张表存储. 那么数据的id可以对`分表数`进行`取模`. 得到的0,1,2,3 会分别按照余数的结果存入不同的表中.

    ![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425135713476-1055995736.png)

    - 优点 : 订单数据可以均匀的放到那4张表中，这样此订单进行操作时，就不会有热点问题。
        >热点: 热点的意思就是对订单进行操作集中到1个表中，其他表的操作很少。 订单有个特点就是时间属性，一般用户操作订单数据，都会集中到这段时间产生的订单。如果这段时间产生的订单 都在同一张订单表中，那就会形成热点，那张表的压力会比较大。

    - 缺点: 数据的迁移和扩容会很困难. 
        > 业务发展很好，订单量很大，超出了4000万的量，那我们就需要增加分表数。如果我们增加4个表. 一旦我们增加了分表的总数，取模的基数就会变成8，以前id=12的订单按照此方案就会到4表中查询，但之前的此订单时在0表的，这样就导致了数据查不到。就是因为取模的基数产生了变化。遇到这个情况，我们想到的方案就是做数据迁移，把之前的4000万数据，重新做一个hash方案，放到新的规划分表中。也就是我们要做数据迁移。这个是很痛苦的事情。有些小公司可以接受晚上停机迁移，但大公司是不允许停机做数据迁移的。

---
- range范围方案 (不需要做数据迁移的方案)

    range方案也就是以范围进行拆分数据.

    ![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425140410364-708893126.png)

    - 优点: 此方案是不是有利于将来的扩容，不需要做数据迁移。即时再增加4张表，之前的4张表的范围不需要改变，id=12的还是在0表，id=1300万的还是在1表，新增的4张表他们的范围肯定是 大于 4000万之后的范围划分的。
    - 缺点: 有热点问题，我们想一下，因为id的值会一直递增变大，那这段时间的订单是不是会一直在某一张表中，如id=1000万 ～ id=2000万之间，这段时间产生的订单是不是都会集中到此张表中，这个就导致1表过热，压力过大，而其他的表没有什么压力。

---
- 两者结合的方案

    上面两种解决方案都不太稳. 那么我们思考一下将两者结合到一起怎么做?
    
    - 这里需要提出一个group的概念.

    ![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425142427136-1144264794.png)

    > 总结上图: \
    0~4000万的数据肯定会落入到group01当中; \
    group01有三个DB, 怎么确定每个ID落入哪个DB?\
    根据hash取模, 那么模数为多少? 是DB数还是总表数? \
    如果用表数作为模数, 那么id=12对10取余后为2, 是落入哪个DB中的哪个表中?

    ![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425143029003-821178421.png)

    > 总结上图:\
    可以看到如果用总表数作为模数, 0~4k万的数据会平均落到3个DB中;\
    余数为0,1,2,3的数据对应DB_0的table_0,table_1,table_2,table_3, 其他两个DB类似.\
    DB的表数不一样是为了保证服务器更好地利用.

    - 进行扩容, 就是增加一个group

    ![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425143429185-1535111626.png)

    - 理论上成立, 怎么实现?

    设计三张表, 分别是 group, DB, table表, 如下:

    ![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425144013684-1788677919.png)

    >根据这三张表来定位数据即可. 同时可以将这三张表(因为一般情况不会频繁扩容), 放入内存中, 增加效率.\
    路由key（如：id）的值是非常关键的，要求一定是有序的，自增的，这个就涉及到分布式唯一id的方案.


