# 分布式DB唯一ID生成方案

<font face="Microsoft Yahei">

能够避免热点问题以及数据迁移问题的分布式数据库要求唯一ID的特性:
>1、整个系统ID唯一\
2、ID是数字类型，而且是趋势递增的\
3、ID简短，查询效率快

趋势递增: 
>如：在一段时间内，生成的ID是递增的趋势。如：再一段时间内生成的ID在【0，1000】之间，过段时间生成的ID在【1000，2000】之间。但在【0-1000】区间内的时候，ID生成有可能第一次是12，第二次是10，第三次是14。

## 一般的ID解决方案

### GUID或者UUID

优点:
>1、代码实现简单。\
2、本机生成，没有性能问题\
3、因为是全球唯一的ID，所以迁移数据容易

缺点:
>1、每次生成的ID是无序的，无法保证趋势递增\
2、UUID的字符串存储，查询效率慢\
3、存储空间大\
4、ID本身无业务含义，不可读

适用场景:
>1、类似生成token令牌的场景\
2、不适用一些要求有趋势递增的ID场景

### SQL Server/MySql 主键自增

优点:
>1、数字化，id递增\
2、查询效率高\
3、具有一定的业务可读

缺点:
>1、存在单点问题，如果server挂了，就没法生成iD了\
2、数据库压力大，高并发抗不住

### 超diao的雪花(snowflake)算法

>雪花算法算出64位2进制正整数, 再转化成十进制. 其中64位2进制数由如下部分组成:

![](https://img2018.cnblogs.com/blog/1216080/201904/1216080-20190425153344616-601617749.png)
>`1位标识符`：始终是0\
`41位时间戳`：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的\
`10位机器标识码`：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成\
`12位序列`：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号

优点:
>1、此方案每秒能够产生409.6万个ID，性能快\
2、时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增\
3、灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求

缺点:
>1、依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成

在分布式场景中，服务器时钟回拨会经常遇到，一般存在10ms之间的回拨；小伙伴们就说这点10ms，很短可以不考虑吧。但此算法就是建立在毫秒级别的生成方案，一旦回拨，就很有可能存在重复ID.

### 越往下介绍越不会系列: redis生成方案

利用redis的incr原子性操作自增，一般算法为：
>年份 + 当天距当年第多少天 + 天数 + 小时 + redis自增

优点：
>有序递增，可读性强

缺点：
>占用带宽，每次要向redis进行请求. 一旦redis挂了，整个系统不可用.\
用户是可以预测下一个id号是多少，因为算法是递增的. 这种方式会被竞争对手推算出平台一天的订单量.